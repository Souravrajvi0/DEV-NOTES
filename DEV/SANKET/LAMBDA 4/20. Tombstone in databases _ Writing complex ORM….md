## üí° MySQL Column Type Cheat Sheet

|Use Case|Suggested Type|Storage / Range (Signed)|Notes / When to Upgrade|
|---|---|---|---|
|**Auto-increment IDs**|INT|4 bytes, -2,147,483,648 ‚Üí 2,147,483,647|Usually enough; use BIGINT if expecting >2B rows|
|**Huge IDs / counters**|BIGINT|8 bytes, ¬±9.22√ó10¬π‚Å∏|Rare; only for massive-scale apps|
|**Small counters / flags**|TINYINT|1 byte, -128 ‚Üí 127|0/1 or small status codes|
|**Moderate counters**|SMALLINT|2 bytes, -32,768 ‚Üí 32,767|Useful for small lookup tables|
|**Regular numeric values**|INT / DECIMAL|INT = 4 bytes, DECIMAL(n,m) precise numbers|Money often stored as DECIMAL to avoid float rounding|
|**Large numeric / money**|BIGINT / DECIMAL|BIGINT = 8 bytes|For very large amounts, or storing cents instead of decimals|
|**Short text (names, titles)**|VARCHAR(n)|1 byte per char + 1/2 bytes length overhead|n = max chars expected|
|**Long text**|TEXT / MEDIUMTEXT|Up to 65k / 16M chars|For descriptions, content|
|**Dates & times**|DATE / DATETIME / TIMESTAMP|3‚Äì8 bytes|Choose based on needed precision and timezone handling|
|**Boolean**|TINYINT(1)|1 byte|MySQL doesn‚Äôt have native BOOLEAN; 0 = false, 1 = true|
### üîπ Practical Tips

1. **Always estimate your max value** first.
    
2. **Use the smallest type** that safely fits the data ‚Äî saves space & improves performance.
    
3. **For IDs**: INT is standard, BIGINT only if you expect huge scale.
    
4. **Money**: Use `DECIMAL` or store in cents as INT to avoid floating point rounding issues.
    
5. **Flags / enums**: TINYINT is perfect.

![image-652.png](../../Images/image-652.png)


![image-653.png](../../Images/image-653.png)


![image-654.png](../../Images/image-654.png)

![image-655.png](../../Images/image-655.png)

You can write migrations in **two main ways**:

1. **SQL-based (raw SQL)**
    
2. **QueryInterface (Sequelize helpers)**

## 1Ô∏è‚É£ SQL-based migrations (raw SQL)

- You literally write **SQL statements** in your migration file.
    
- Sequelize just runs them for you.
```ts
export async function up(queryInterface: any, Sequelize: any) {
  await queryInterface.sequelize.query(`
    CREATE TABLE users (
      id INT PRIMARY KEY AUTO_INCREMENT,
      name VARCHAR(255) NOT NULL,
      email VARCHAR(255) UNIQUE NOT NULL,
      createdAt DATETIME NOT NULL,
      updatedAt DATETIME NOT NULL
    );
  `);
}

```


### ‚úÖ Pros:

- Full control over **exact SQL syntax**.
    
- Can use **DB-specific features** (e.g., MySQL triggers, indexes).
    
- Works even if you don‚Äôt use Sequelize models.
    

### ‚ùå Cons:

- Less portable (SQL dialect-specific).
    
- More error-prone for big schema changes.
    
- You need to manually write `createdAt`/`updatedAt` if you want timestamps.


## 2Ô∏è‚É£ QueryInterface-based migrations (Sequelize helpers)

- Sequelize provides **helper functions** that abstract SQL.

```ts
export async function up(queryInterface: any, Sequelize: any) {
  await queryInterface.createTable('Users', {
    id: {
      type: Sequelize.INTEGER,
      autoIncrement: true,
      primaryKey: true,
    },
    name: {
      type: Sequelize.STRING,
      allowNull: false,
    },
    email: {
      type: Sequelize.STRING,
      allowNull: false,
      unique: true,
    },
    createdAt: {
      type: Sequelize.DATE,
      allowNull: false,
    },
    updatedAt: {
      type: Sequelize.DATE,
      allowNull: false,
    },
  });
}

```

### ‚úÖ Pros:

- **DB-agnostic** ‚Üí works across MySQL, Postgres, SQLite, etc.
    
- Cleaner, easier to read and maintain.
    
- Works well with Sequelize models.
    

### ‚ùå Cons:

- Less control over raw SQL optimizations.
    
- Some advanced DB features might not be supported directly.


## 3Ô∏è‚É£ When to use which

|Scenario|Recommended method|
|---|---|
|Simple table/column changes|QueryInterface (Sequelize helper)|
|Complex SQL features (views, triggers, raw joins, custom indexes)|Raw SQL|
|Need DB-agnostic migrations|QueryInterface|
|Need full control over performance|Raw SQL|

---

## 4Ô∏è‚É£ Mental model

- **QueryInterface** = ‚ÄúSequelize speaks for me in its own language‚Äù ‚Üí safer, portable
    
- **Raw SQL** = ‚ÄúI speak directly to the DB‚Äù ‚Üí full control, but more responsibility



**Multiple ways to do CRUD**:

## 1Ô∏è‚É£ Using **Model objects** (OOP style)

- This is **object-oriented**, uses the **Model class**.
    
- Works directly with Sequelize models, strongly typed in TypeScript.

```ts
// Create
const user = await User.create({ name: "Sourav", email: "rajvi@example.com" });

// Read
const foundUser = await User.findByPk(1);

// Update
await User.update({ name: "Rajvi" }, { where: { id: 1 } });

// Delete (soft or hard depending on model)
await User.destroy({ where: { id: 1 } });

```


‚úÖ Pros:

- Fully integrated with **Sequelize models**.
    
- Works with **associations, hooks, validations**.
    
- Typescript types work nicely (`InferAttributes`, `CreationOptional`, etc.).
    

---

## 2Ô∏è‚É£ Using **raw SQL** (queryInterface or sequelize.query)

- Sometimes you need **complex queries** not easily expressed via the model.
    
- You can write **SQL directly** and execute it via Sequelize.



![image-656.png](../../Images/image-656.png)


![image-657.png](../../Images/image-657.png)


# **Sequelize CRUD Cheat Sheet**

|Operation|Model / OOP Style|Raw SQL Style (`sequelize.query`)|
|---|---|---|
|**Create**|`ts const user = await User.create({ name: "Sourav", email: "rajvi@example.com" });`|``ts await sequelize.query(` INSERT INTO Users (name, email, createdAt, updatedAt) VALUES ('Sourav', 'rajvi@example.com', NOW(), NOW()); `);``|
|**Read (all)**|`ts const users = await User.findAll();`|``ts const [users] = await sequelize.query(` SELECT * FROM Users; `);``|
|**Read (by ID)**|`ts const user = await User.findByPk(1);`|``ts const [user] = await sequelize.query(` SELECT * FROM Users WHERE id = 1; `);``|
|**Read (with condition)**|`ts const users = await User.findAll({ where: { name: "Sourav" } });`|``ts const [users] = await sequelize.query(` SELECT * FROM Users WHERE name = 'Sourav'; `);``|
|**Update**|`ts await User.update({ name: "Rajvi" }, { where: { id: 1 } });`|``ts await sequelize.query(` UPDATE Users SET name = 'Rajvi' WHERE id = 1; `);``|
|**Delete (hard)**|`ts await User.destroy({ where: { id: 1 }, force: true });`|``ts await sequelize.query(` DELETE FROM Users WHERE id = 1; `);``|
|**Delete (soft, paranoid)**|`ts await User.destroy({ where: { id: 1 } }); // sets deletedAt timestamp if paranoid:true`|``ts await sequelize.query(` UPDATE Users SET deletedAt = NOW() WHERE id = 1; `);``|
|**Count**|`ts const count = await User.count({ where: { name: "Sourav" } });`|``ts const [{ count }](%7B%20count%20%7D.md) = await sequelize.query(` SELECT COUNT(*) as count FROM Users WHERE name = 'Sourav'; `);``|
|**Raw query with join**|Not directly via model ‚Äî use `sequelize.query`|``ts const [results] = await sequelize.query(` SELECT u.id, u.name, COUNT(o.id) as orders FROM Users u LEFT JOIN Orders o ON o.userId = u.id GROUP BY u.id; `);``|

---

### ‚úÖ Tips:

1. **Use OOP / Model style** for normal CRUD ‚Äî safer, type-checked, supports hooks, associations, validations.
    
2. **Use Raw SQL** for:
    
    - Complex joins
        
    - Aggregate reports
        
    - DB-specific features or performance optimizations
        
3. You **can mix both** in the same project ‚Äî most teams do.
# **Backend Flow Diagram**

```d
POST /users (from Postman / Mobile / Web)
        ‚îÇ
        ‚ñº
========================
  DTO Layer (Data Transfer Object)
========================
- Defines the **shape** of incoming data
- Example: CreateUserDto { name, email, password }
- Ensures only expected fields pass through
        ‚îÇ
        ‚ñº
========================
  Validator Layer
========================
- Checks **rules / constraints**
  - name: string, not empty
  - email: valid email
  - password: min 6 chars
- Can throw errors before hitting service
        ‚îÇ
        ‚ñº
========================
  Controller Layer
========================
- Receives request DTO (validated)
- Calls Service Layer
- Returns response DTO
        ‚îÇ
        ‚ñº
========================
  Service Layer (Business Logic)
========================
- Contains application logic
- Decides how to create/update/fetch/delete data
- Can call:
    - **Model CRUD** (OOP style)
        Example: User.create(dto)
    - **Raw SQL** (for complex queries)
        Example: sequelize.query(`SELECT ... JOIN ...`)
        ‚îÇ
        ‚ñº
========================
  Model / Database Layer
========================
- Sequelize Models represent tables
- Soft delete, associations, hooks handled here
- Database executes queries
        ‚îÇ
        ‚ñº
========================
  Response DTO
========================
- Filters/structures data before sending back
- Removes sensitive info (e.g., passwordHash)
        ‚îÇ
        ‚ñº
Postman / Mobile / Web (Client receives JSON)

```


![image-658.png](../../Images/image-658.png)


## 2Ô∏è‚É£ Common **static methods** (Model-level, call on the class)

| Method                    | Description                   | Example                                                                       |
| ------------------------- | ----------------------------- | ----------------------------------------------------------------------------- |
| `findByPk(pk)`            | Find row by primary key       | `const user = await User.findByPk(1);`                                        |
| `findOne(options)`        | Find first row matching query | `const user = await User.findOne({ where: { email: "a@b.com" } });`           |
| `findAll(options)`        | Find multiple rows            | `const users = await User.findAll({ where: { name: "Sourav" }, limit: 10 });` |
| `create(values)`          | Insert new row                | `const user = await User.create({ name: "Sourav", email: "a@b.com" });`       |
| `update(values, options)` | Update rows                   | `await User.update({ name: "Rajvi" }, { where: { id: 1 } });`                 |
| `destroy(options)`        | Delete rows                   | `await User.destroy({ where: { id: 1 } });`                                   |
| `count(options)`          | Count rows matching query     | `const c = await User.count({ where: { name: "Sourav" } });`                  |
| `bulkCreate(array)`       | Insert multiple rows          | `await User.bulkCreate([{name:"A"}, {name:"B"}]);`                            |
![image-659.png](../../Images/image-659.png)

![image-660.png](../../Images/image-660.png)



Even if we use paranoid property we still need to have the deletedAt field
![image-661.png](../../Images/image-661.png)


## 1Ô∏è‚É£ **Stored Procedures (DB concept)**

**Definition:**  
A stored procedure is a **predefined SQL program saved in the database** that can perform operations like `SELECT`, `INSERT`, `UPDATE`, `DELETE`, or even complex business logic.

- Runs on the **database server**, not in your app.
    
- Can take **parameters** and return **results**.

![image-662.png](../../Images/image-662.png)

![image-663.png](../../Images/image-663.png)


![image-664.png](../../Images/image-664.png)


![image-665.png](../../Images/image-665.png)


![image-666.png](../../Images/image-666.png)

Triggers are purely a **database-level feature**, so you always need to use **raw SQL** to create them.


![image-667.png](../../Images/image-667.png)


### 3Ô∏è‚É£ Summary

|Approach|Runs Where|Pros|Cons|
|---|---|---|---|
|Raw SQL trigger in migration|Database|Works for all clients, automatic|Must write SQL manually|
|Sequelize hooks|App (Node)|Easier to maintain in JS|Only works via Sequelize operations|

---

üí° Key point: If you want **DB-level guarantees**, you **must use raw SQL**. Sequelize hooks are just an app-level alternative.


## 3Ô∏è‚É£ **Hooks (Sequelize concept)**

**Definition:**  
Hooks are **functions you attach to models** that run **before or after certain actions** in Sequelize (insert, update, delete, find).

- Runs **inside your app**, not in DB.
    
- Can modify data, perform checks, log actions, etc.
    

**Types of hooks:**

|Hook|When it runs|
|---|---|
|`beforeCreate`|Before `create()` is executed|
|`afterCreate`|After `create()` completes|
|`beforeUpdate`|Before `update()`|
|`afterUpdate`|After `update()`|
|`beforeDestroy`|Before `destroy()`|
|`afterDestroy`|After `destroy()`|
|`beforeFind`|Before `findAll` / `findOne`|
|`afterFind`|After fetching data|


```ts
User.beforeCreate((user, options) => {
  user.name = user.name.trim();  // sanitize name before saving
});

User.afterCreate((user, options) => {
  console.log(`New user created: ${user.name}`);
});

```


**Difference from triggers:**

- **Trigger:** DB-level, runs automatically even if app doesn‚Äôt exist.
    
- **Hook:** ORM-level, runs in your app via Sequelize methods.


## 4Ô∏è‚É£ Quick Comparison

|Concept|Runs Where|Purpose / Use Case|
|---|---|---|
|Stored Procedure|Database|Encapsulate complex DB logic|
|Trigger|Database|Auto-run SQL on table events|
|Hook|Sequelize App|Run JS code before/after model actions|


## Hooks operate on **Sequelize objects**

- Hooks run **inside your Node.js app**, whenever you call a Sequelize method (`create`, `update`, `destroy`, `find`, etc.).
    
- They operate on **instances of your model**, i.e., JS objects representing DB rows

![image-668.png](../../Images/image-668.png)


## Key points

1. **Hooks are mostly JS-level**, working on model instances.
    
2. **DB interaction occurs when Sequelize executes the query**, which hooks can **intercept, modify, or react to**.
    
3. Hooks are **conditional** ‚Äî you can add logic like:
![image-669.png](../../Images/image-669.png)


![image-670.png](../../Images/image-670.png)


![image-671.png](../../Images/image-671.png)

## 2Ô∏è‚É£ Scope of hooks

- Hooks attached to a **model class** will run **for every instance of that model** when the associated action is called.
    
- You **cannot attach hooks to a single row instance**; it‚Äôs always **at the model level**.


Let‚Äôs take a **Hotel model** example and write **practical hooks** you‚Äôd use in a real app. I‚Äôll cover `beforeCreate`, `afterCreate`, `beforeUpdate`, `beforeDestroy`, and `afterFind`.

![image-672.png](../../Images/image-672.png)


![image-673.png](../../Images/image-673.png)


![image-674.png](../../Images/image-674.png)
![image-675.png](../../Images/image-675.png)

A **tombstone** in a database is basically a **marker that indicates a record has been deleted** without actually removing it from the database immediately. It‚Äôs widely used in distributed databases and systems that implement **soft deletes**. Let me explain in detail:

---

### 1Ô∏è‚É£ Concept

- Instead of physically deleting a record, the database marks it as deleted using a **tombstone flag** or **deleted timestamp**.
    
- The record is still stored in the DB, but the system treats it as ‚Äúdeleted.‚Äù
    
- This is common in systems that need **replication, auditing, or conflict resolution**
![image-676.png](../../Images/image-676.png)


![image-677.png](../../Images/image-677.png)


![image-678.png](../../Images/image-678.png)


**Entities involved:**

1. Problem
    
2. Submissions (users‚Äô solutions)
    
3. Contests
    
4. User ratings
    
5. Discussion/comments
    
6. Tags / topics
    

---

### 1Ô∏è‚É£ What happens if we do a hard delete

- **Problem table** ‚Üí row removed
    
- **Submissions table** ‚Üí foreign key references break ‚Üí submissions get deleted or become orphaned
    
- **Contest table** ‚Üí if the problem was part of a contest, the contest structure breaks
    
- **Ratings** ‚Üí recalculation needed, because users‚Äô contest performance depended on the problem
    
- **Discussions / comments / solutions** ‚Üí could also break
    

‚ö†Ô∏è **Potential issues:**

- Orphaned records ‚Üí database integrity errors
    
- Users‚Äô historical data disappears ‚Üí affects leaderboards, ratings
    
- Contests may become invalid ‚Üí unfair or broken scoring
    
- Analytics/statistics become inconsistent


![image-679.png](../../Images/image-679.png)



# 1. The Two Worlds in Any App

Whenever you build a system, there are **two domains** at play:

### üü¶ Application Layer (JS/ORM)

- Written in JavaScript/TypeScript (or any app language).
    
- Holds **business logic**: rules like _‚Äúa user can‚Äôt place an order if their account is inactive‚Äù_.
    
- Talks to the DB indirectly, usually through an **ORM** or repository.
    
- Fast-changing: features, product rules, workflows ‚Üí these evolve weekly/monthly.
    

### üü® Database Layer

- The **source of truth** where data is persisted.
    
- Holds **data integrity and performance logic**: indexes, constraints, query optimizations, compaction (in NoSQL), replication.
    
- Slower-changing: schema design, partitioning, query tuning ‚Üí these are expensive to redo and evolve slower.
    

üëâ Think of it like:  
**App Layer = ‚ÄúWhat should happen?‚Äù**  
**DB Layer = ‚ÄúHow the data is actually stored and kept correct?‚Äù**


# 2. Why Split Them?

If you mix both, you get brittle systems.  
Example: putting all rules in DB procedures makes it hard to test or change quickly.  
Or, putting all responsibility in JS means you ignore DB mechanics like tombstones, indexes, or constraints.

The split gives:

- **Agility** ‚Üí tweak business rules quickly in JS.
    
- **Integrity** ‚Üí DB enforces correctness & optimizes data access.
# 3. Responsibilities of Each Layer

### Application Layer (JS/ORM)

- **Business workflows** (placeOrder, deactivateUser, refundPayment).
    
- **Validation** (email format, password length, order amount > 0).
    
- **Orchestration** across services (call payments API + persist order).
    
- **Soft deletes** (mark `is_deleted = true`) instead of hard deletes.
    
- **Repository abstraction**: ORM models hide raw queries, so code doesn‚Äôt care if DB is MySQL, Postgres, Cassandra, etc.
    

### Database Layer

- **Constraints** (unique email, foreign key, not null).
    
- **Indexes** for query speed.
    
- **Replication/consistency** (Cassandra tombstones, PostgreSQL WAL, etc).
    
- **Performance tuning** (partitioning, compaction, vacuum).
    
- **Physical delete semantics** (tombstones in Cassandra, vacuum in Postgres).



![image-903.png](../../Images/image-903.png)


# 5. ORM as the Bridge

The ORM is the translator between these worlds:

- **ORM entity/model** = represents a DB row but lives in code.
    
- ORM can map:
    
    - `softDelete()` ‚Üí just sets `is_deleted = true`.
        
    - `hardDelete()` ‚Üí actually issues a DB delete (and triggers tombstones in Cassandra).
        
- Good ORMs let you _choose_ the strategy so you don‚Äôt unknowingly harm DB performance.
    

---

# 6. General Rule of Thumb

- **Keep business logic in JS/ORM layer** (soft delete flags, validation, workflows).
    
- **Keep data correctness/performance in DB layer** (constraints, indexes, compaction policies).
    
- **Only push heavy set-based logic down** (e.g., ‚Äúaggregate orders by month‚Äù is cheaper in DB).
    

This is why engineers say:  
üëâ ‚ÄúApp owns the _what_, DB owns the _how_.‚Äù


