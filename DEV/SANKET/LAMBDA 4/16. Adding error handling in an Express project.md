

![image-496.png](../../Images/image-496.png)


![image-497.png](../../Images/image-497.png)

## 3Ô∏è‚É£ What actually gets sent over the network

When you do either `res.send()` or `res.json()`:

- Data is converted into a **string** (if not already)
    
- Sent over HTTP as raw text (bytes)
    
- Browser or client parses it based on the **Content-Type** header

## 4Ô∏è‚É£ In REST APIs, what do we use and why?

In REST:

- **JSON** is the standard for data exchange (`application/json`)
    
- Why?
    
    - Lightweight
        
    - Human-readable
        
    - Language-agnostic
        
    - Easy to parse in clients
        

So in practice:

- Use `res.json()` when sending structured data.
    
- Use `res.send()` when sending plain text, HTML, or non-JSON responses.

| Method       | Auto Content-Type | Data type flexibility  | Common in REST?                                     |
| ------------ | ----------------- | ---------------------- | --------------------------------------------------- |
| `res.send()` | Depends on input  | ‚úÖ Any type             | ‚ö†Ô∏è Only if sending text or already-stringified JSON |
| `res.json()` | application/json  | üö´ Only objects/arrays | ‚úÖ Yes, standard                                     |
![image-498.png](../../Images/image-498.png)

![image-499.png](../../Images/image-499.png)

![image-500.png](../../Images/image-500.png)


## 5Ô∏è‚É£ TL;DR mental model

**Request**:  
Client says ‚Äî _"I‚Äôm sending you data in this format"_ ‚Üí via `Content-Type` header  
Server uses middleware to parse it.

**Response**:  
Server says ‚Äî _"I‚Äôm sending you data in this format"_ ‚Üí via `Content-Type` header  
Client (Postman, browser, mobile app) parses it accordingly.


```ts
export const pingHandler = async (req: Request, res: Response): Promise<void> => {
  res.json({
    message: "Pong",
    success: true
  });
};

```

![image-501.png](../../Images/image-501.png)

![image-502.png](../../Images/image-502.png)

![image-503.png](../../Images/image-503.png)

### `async (req: Request, res: Response): Promise<void> => { ... }`

- **`async`**: This function can use `await` inside it (useful if you need to fetch from DB, call APIs, etc.).
    
- **`req: Request`**:  
    Type annotation from Express ‚Äî `req` is the incoming HTTP request object.
    
- **`res: Response`**:  
    Type annotation from Express ‚Äî `res` is the HTTP response object you send data back with.
    
- **`: Promise<void>`**:  
    This function returns a Promise that resolves to nothing (`void`), which is normal for an Express handler.




![image-504.png](../../Images/image-504.png)


![image-505.png](../../Images/image-505.png)

## üî¥ 3. Why this matters

- If **your code throws synchronously** (during that call), Express is still inside its `try/catch`, so it catches it.
    
- If **your code throws later (async)**, then Express‚Äôs `try/catch` is already finished ‚Üí the error ‚Äúescapes‚Äù ‚Üí Express never sees it ‚Üí you must manually call `next(err)`.

![image-506.png](../../Images/image-506.png)

![image-507.png](../../Images/image-507.png)

![image-508.png](../../Images/image-508.png)

![image-509.png](../../Images/image-509.png)

- **Sync throw** ‚Üí Express internally does `next(err)` for you.
    
- **Async** ‚Üí you must do `next(err)` yourself.
    
- In both cases, if you don‚Äôt write your own error handler, Express eventually calls its **built-in default handler**.

![image-510.png](../../Images/image-510.png)


![image-511.png](../../Images/image-511.png)



We need  To send some custom error response instead of sending this generic code all the time!!!

 Also error handling logic can be same for a lot of cases!!!!!!

![image-512.png](../../Images/image-512.png)


![image-513.png](../../Images/image-513.png)


![image-514.png](../../Images/image-514.png)
![image-515.png](../../Images/image-515.png)
![image-516.png](../../Images/image-516.png)

![image-517.png](../../Images/image-517.png)


![image-518.png](../../Images/image-518.png)

![image-519.png](../../Images/image-519.png)

![image-520.png](../../Images/image-520.png)


![image-521.png](../../Images/image-521.png)


![image-522.png](../../Images/image-522.png)


![image-523.png](../../Images/image-523.png)


![image-524.png](../../Images/image-524.png)

![image-525.png](../../Images/image-525.png)


![image-526.png](../../Images/image-526.png)


![image-527.png](../../Images/image-527.png)

![image-528.png](../../Images/image-528.png)

# üéØ Final Takeaway

- **Polymorphism** = same method, different behavior depending on object.
    
- **Inheritance (classes)** = good for reusing code in a straight hierarchy.
    
- **Problem**: Real-world systems often need **multiple capabilities**, which inheritance can‚Äôt handle (no multiple inheritance).
    
- **Interfaces** = let you **compose multiple abilities** flexibly, without messy inheritance chains.
    
- **Best practice**: Use interfaces for contracts (e.g., UpiEnabled, EmiEnabled), use abstract classes for shared logic.


# üßë‚Äçüè´ Can interfaces and classes extend each other?

---

## 1. **Interface extending a class**

Yes, in **TypeScript**, an interface can extend a class.  
üëâ But what does that mean?

When an interface extends a class:

- It takes the **shape (properties + methods)** of that class.
    
- It does **not** inherit the implementation (only the structure).


![image-529.png](../../Images/image-529.png)


![image-530.png](../../Images/image-530.png)


![image-531.png](../../Images/image-531.png)


## 4. **Summary Table**

|Case|Allowed?|Explanation|
|---|---|---|
|**Interface extends Class**|‚úÖ Yes|Copies the structure of the class (not code).|
|**Class extends Interface**|‚ùå No|A class must `implement` an interface instead.|
|**Interface extends Interface**|‚úÖ Yes|Can extend one or multiple interfaces.|
|**Class extends Class**|‚úÖ Yes|Normal inheritance (single only).|

---

‚ö°Ô∏è Rule of thumb:

- **extends** = taking structure + (if class) code.
    
- **implements** = agreeing to a contract (must provide implementation yourself).



![image-532.png](../../Images/image-532.png)



![image-533.png](../../Images/image-533.png)


![image-534.png](../../Images/image-534.png)


![image-535.png](../../Images/image-535.png)


![image-536.png](../../Images/image-536.png)



Your code should be in such a way that express error handler should be called!  Your code should go through all the test cases!! 


