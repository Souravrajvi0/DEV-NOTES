### Go **doesnâ€™t have classes** in the traditional OOP sense like Java or C++. Instead, Go uses **structs** and **methods** to achieve similar functionality. Think of structs as â€œblueprints for objectsâ€ and methods as â€œfunctions tied to those objects.â€


## **1ï¸âƒ£ Structs â€” Goâ€™s version of classes**

A `struct` is a composite data type that groups together variables (called **fields**) under a single name.

```go
package main

import "fmt"

// Define a struct
type Person struct {
    Name string
    Age  int
}

func main() {
    // Create an instance of Person
    p1 := Person{Name: "Sourav", Age: 26}
    
    fmt.Println(p1.Name) // Sourav
    fmt.Println(p1.Age)  // 26
}

```


Here:

- `Person` is like a **class**.
    
- `Name` and `Age` are **fields**.
    
- `p1` is like an **object/instance** of the class


In Go, structs are just **data containers**, like plain objects in JS, but the way you attach â€œmethodsâ€ is a bit different. You **donâ€™t define methods inside the struct itself** like you would in JS classes. Instead, you define methods **separately** but attach them to the struct using a **receiver**.

```go
type Product struct {
    name    string
    price   int
    company string
}

func main() {
    p := Product{
        name:    "iPhone 15 Pro",
        price:   100,
        company: "Apple Inc.",
    }
fmt.Println("Product Name:", p.name)


```

1. `type Product struct { ... }`
    
    - This defines a **struct** named `Product`.
        
    - A struct is like a **blueprint for an object**.
        
2. Inside the struct:
    
    - `name string` â†’ the product has a `name` field of type `string`.
        
    - `price int` â†’ the product has a `price` field of type `int`.
        
    - `company string` â†’ the product has a `company` field of type `string`.
        

Think of this as a **class with three properties**.



- `func main()` â†’ entry point of a Go program.
    
- `p := Product{...}` â†’ creates an **instance** of the `Product` struct.
    
    - `p` is now a variable holding the product object.
        
    - We assign values to each field using **field names**:
        
        - `name: "iPhone 15 Pro"`
            
        - `price: 100`
            
        - `company: "Apple Inc."`

![image-850.png](../../Images/image-850.png)


![image-851.png](../../Images/image-851.png)

```go
package main

import "fmt"

// Product defines a product with a name, price, and company.
type Product struct {
	name    string
	price   int
	company string
}

// fun attempts to modify the name of a Product.
// Because Go passes by value, this function receives a copy of the Product,
// and any modifications made inside this function will not affect the original.
func fun(p Product) {
	// this p is a copy of the product passed to this function
	p.name = "MacBook Pro"
	fmt.Println("Product Name inside function:", p.name)
}

func main() {
	// Initialize a Product variable
	p := Product{
		name:    "iPhone 15 Pro",
		price:   1000,
		company: "Apple Inc.",
	}

	// Print the product name before calling the function
	fmt.Println("Product Name before function call:", p.name)

	// Call the function with the Product variable.
	// A copy of 'p' is passed to 'fun'.
	fun(p)

	// Print the product name after the function call.
	// The name will remain unchanged because the function modified a copy.
	fmt.Println("Product Name after function call:", p.name)
}

```



# Why nothing changed when you passed your `Product` â€” from scratch

Short answer: **Go passes arguments by value**. When you call `fun(p)` you give `fun` a _copy_ of `p`. Any changes inside `fun` only modify that copy â€” the original `p` in `main` stays the same.

Go doesnâ€™t have â€œobjectsâ€ like Java/C# classes; it has **structs** (and methods on them). Passing a struct value means copying its fields. To mutate the original, pass a **pointer** to it.



## How to change the original: pass a pointer

Pass the address (`&p`) and accept a `*Product` in the function


```go
func funPtr(p *Product) {
    p.name = "MacBook Pro"         // modifies the original because p points to it
    fmt.Println("Product Name inside funPtr:", p.name)
}

func main() {
    p := Product{name: "iPhone 15 Pro", price: 1000, company: "Apple"}
    fmt.Println("Before:", p.name)
    funPtr(&p)         // pass pointer to p
    fmt.Println("After:", p.name) // now changed
}

```

`funPtr` receives the _same_ memory address, so changes are visible to the caller.

- If you want to **mutate** the original value, pass a pointer (`*T`).
    
- If the struct is **large** and you want to avoid copying overhead, use a pointer.
    
- If the value is **small & immutable** (e.g., 2â€“3 fields, cheap to copy), value receivers are fine and sometimes clearer.
    
- Be careful with pointers across goroutines â€” synchronize access (mutexes) to avoid race conditions.


- `fun(p Product)` â†’ function gets a fresh copy: `|p(main)| -> |p(fun: copy)|`
    
- `funPtr(&p)` â†’ function gets a pointer to the same box: `|p(main)| <-pointer- |p(fun) points here|`




Go doesnâ€™t have **constructors** the way Java/C++/Python do (with `__init__` or class constructors).

Instead, in Go we use a **regular function** (by convention called `New<TypeName>`) that returns either:

- a value (`Product`) if you want immutability / copy
    
- or a pointer (`*Product`) if you want to modify the instance later

### Example: Constructor for `Product`

```go
package main

import "fmt"

// Product struct
type Product struct {
	name    string
	price   int
	company string
}

// Constructor function (returns pointer)
func NewProduct(name string, price int, company string) *Product {
	return &Product{
		name:    name,
		price:   price,
		company: company,
	}
}

func main() {
	// Use constructor
	p := NewProduct("iPhone 15 Pro", 1000, "Apple Inc.")

	fmt.Println("Name:", p.name)
	fmt.Println("Price:", p.price)
	fmt.Println("Company:", p.company)
}

```

![image-852.png](../../Images/image-852.png)


![image-853.png](../../Images/image-853.png)

![image-854.png](../../Images/image-854.png)

## 1. Functions vs Methods in Go


![image-856.png](../../Images/image-856.png)


## ğŸ”¹ 2. What is a Method in Go?

![image-857.png](../../Images/image-857.png)


![image-858.png](../../Images/image-858.png)

![image-859.png](../../Images/image-859.png)

![image-860.png](../../Images/image-860.png)


![image-861.png](../../Images/image-861.png)

![image-862.png](../../Images/image-862.png)


```go
package main

import "fmt"

type Product struct {
    name    string
    price   int
    company string
}

// Constructor
func NewProduct(name string, price int, company string) *Product {
    return &Product{name, price, company}
}

// Method with pointer receiver
func (p *Product) SetName(name string) {
    p.name = name
}

func main() {
    p := NewProduct("iPhone", 1000, "Apple")
    fmt.Println("Before:", p.name)

    // Call method (Go translates this into SetName(p, ...))
    p.SetName("MacBook Pro")

    fmt.Println("After:", p.name)
}

```


Before: iPhone
After: MacBook Pro

BEFORE : 
![image-864.png](../../Images/image-864.png)
AFTER:
![image-863.png](../../Images/image-863.png)

 Even if we define methods it's better if we create em type of pass by reference only since  you don't wanna create copies again and again if there's no particular usecase!!


![image-865.png](../../Images/image-865.png)

## Why did Go choose this?

Two reasons:

1. **Read left-to-right**  
    In Go, you read declarations as:
    
    > "`a` is an int"  
    > "`p` is a Product"
    
    which is considered more natural in English.
    
2. **Consistency with multiple variables**  

![image-866.png](../../Images/image-866.png)


![image-867.png](../../Images/image-867.png)

![635x351](../../Images/image-868.png)





### 1. What is an Interface?

An **interface** in Go is like a **contract**.  
It says:  
ğŸ‘‰ "Any type that has these methods automatically satisfies this interface."

It doesnâ€™t care about the type itself â€” only that the required methods exist.



![image-869.png](../../Images/image-869.png)


![image-870.png](../../Images/image-870.png)


### 4. Using the Interface

```go
package main

import "fmt"

type Animal interface {
    Speak() string
}

type Dog struct{}

func (d Dog) Speak() string {
    return "Woof!"
}

type Cat struct{}

func (c Cat) Speak() string {
    return "Meow!"
}

func main() {
    // We can store different types in the same interface variable
    var a Animal

    a = Dog{}
    fmt.Println(a.Speak()) // Woof!

    a = Cat{}
    fmt.Println(a.Speak()) // Meow!

    // Or use a slice of interfaces
    animals := []Animal{Dog{}, Cat{}}
    for _, animal := range animals {
        fmt.Println(animal.Speak())
    }
}

```


![image-871.png](../../Images/image-871.png)


![image-872.png](../../Images/image-872.png)


- `method = CreditCard{}` â†’ youâ€™re saying â€œright now, Iâ€™ll pay with credit card.â€
    
- `method = Cash{}` â†’ later, you switch and pay with cash.
    

So the `method` variable is of type **PaymentMethod** (interface), and you can plug in **any payment option** (CreditCard, Cash, UPI, PayPal, etc.) as long as they follow the same contract (`Pay()` method).


In Go:  
ğŸ‘‰ A **struct implements an interface** if it has **all the methods** that the interface requires, with the **exact same signatures** (name, parameters, and return types).  
ğŸ‘‰ You donâ€™t need to write any `implements` keyword like in Java or C#. Itâ€™s **implicit**.

```go
package main

import "fmt"

// Step 1: Define interface
type Shape interface {
    Area() float64
    Perimeter() float64
}

// Step 2: Define struct
type Rectangle struct {
    width, height float64
}

// Step 3: Implement *all* methods from Shape
func (r Rectangle) Area() float64 {
    return r.width * r.height
}

func (r Rectangle) Perimeter() float64 {
    return 2*(r.width + r.height)
}

func main() {
    var s Shape

    s = Rectangle{width: 10, height: 5} // âœ… Rectangle has both methods
    fmt.Println("Area:", s.Area())
    fmt.Println("Perimeter:", s.Perimeter())
}

```


- If `Rectangle` had **only `Area()`** but not `Perimeter()`, it would **NOT** implement `Shape`.  
    Go compiler would give an error if you try to assign it.
    
- The method signatures must match **exactly**.  
    For example:
    
    - If `Shape` requires `Area() float64`
        
    - But your struct has `Area() int` â†’ âŒ doesnâ€™t count.


```go
package main

import (
    "fmt"
    "math"
)

// Step 1: Define the interface
type Shape interface {
    Area() float64
}

// Step 2: Define Rectangle struct
type Rectangle struct {
    width, height float64
}

func (r Rectangle) Area() float64 {
    return r.width * r.height
}

// Step 3: Define Circle struct
type Circle struct {
    radius float64
}

func (c Circle) Area() float64 {
    return math.Pi * c.radius * c.radius
}

// Step 4: Define Triangle struct
type Triangle struct {
    a, b, c float64 // sides
}

// use Heron's formula for area
func (t Triangle) Area() float64 {
    s := (t.a + t.b + t.c) / 2
    return math.Sqrt(s * (s - t.a) * (s - t.b) * (s - t.c))
}

// Step 5: Generic function that works with any Shape
func Draw(s Shape) {
    fmt.Println("Drawing shape, area:", s.Area())
}

func main() {
    r := Rectangle{width: 10, height: 5}
    c := Circle{radius: 7}
    t := Triangle{a: 3, b: 4, c: 5}

    Draw(r)
    Draw(c)
    Draw(t)
}

```


![image-873.png](../../Images/image-873.png)


![image-874.png](../../Images/image-874.png)

So yes â€”

- The structs still hold their methods.
    
- The **interface lets you treat them all generically**, instead of writing separate code for each.

## In Go, **the first letter decides visibility**:

- **Uppercase (Capitalized)** â†’ **Exported** (public, visible outside the package).
    
- **Lowercase** â†’ **Unexported** (private, visible only inside the same package).
    

Thatâ€™s it. No `public`, `private`, `protected` keywords.

## 2. Example: package `mathutils`

Letâ€™s make a simple package:

```go
// mathutils/mathutils.go
package mathutils

// Exported (public)
func Add(a, b int) int {
    return a + b
}

// Exported (public)
func Multiply(a, b int) int {
    return a * b
}

// Unexported (private)
func subtract(a, b int) int {
    return a - b
}

```


Here:

- `Add` âœ… visible outside
    
- `Multiply` âœ… visible outside
    
- `subtract` âŒ hidden (can only be used inside `mathutils`)


## 3. Using it in `main.go`

```go
package main

import (
    "fmt"
    "yourmodule/mathutils"
)

func main() {
    fmt.Println(mathutils.Add(5, 3))      // âœ… works
    fmt.Println(mathutils.Multiply(4, 2)) // âœ… works
    // fmt.Println(mathutils.subtract(5, 3)) // âŒ compile error
}

```

![image-875.png](../../Images/image-875.png)


![image-876.png](../../Images/image-876.png)


In Go, **all files inside the same package share the same visibility**.  
So if two files have the same `package xyz` at the top, they can access each otherâ€™s **lowercase (unexported)** stuff without any issue.


![image-877.png](../../Images/image-877.png)



![image-878.png](../../Images/image-878.png)

- **Capitalized name** (starts with `Aâ€“Z`) â†’ **exported** = visible **outside the package** 
    
- **Lowercase name** (starts with `aâ€“z`) â†’ **unexported** = visible **only inside the same package**.

## IMPORTS

![image-879.png](../../Images/image-879.png)


![image-880.png](../../Images/image-880.png)


ğŸ‘‰ You must run `go mod init myproject` in the root so Go knows the module name.  
ğŸ‘‰ Import path is always `<module-name>/<folder-name>`.


![image-881.png](../../Images/image-881.png)


you are **not just naming your folder**. Youâ€™re actually creating a **module** in Go.

### What is a module?

- A **module** = a collection of Go packages managed together.
    
- Itâ€™s Goâ€™s way of saying: _â€œthis folder is now an independent project, and I can track its dependencies.â€_
    
- The module name (`gobasics`) becomes the **root import path** for all packages inside.


### Why do we need `go mod init`?

1. **Dependency tracking**
    
    - It creates a `go.mod` file.
        
    - That file records:
        
        - your module name
            
        - all external libraries you use (like `github.com/gin-gonic/gin`).
            
2. **Import paths**
    
    - Without `go mod init`, Go doesnâ€™t know what prefix to use when you import your own packages



## go mod init gobasics
you are not just writing your folderâ€™s name.
That word (gobasics) is the module path â€” basically the unique address/name of your project.

### What are we trying to achieve?

We are telling Go:  
ğŸ‘‰ â€œHey, I am starting a new Go project. From now on, if someone imports my project, they will use this name.â€

Thatâ€™s the whole point of `go mod init`.  
It defines the **identity** of your project.


### Why do we often use the folder name?

Because itâ€™s convenient and human-readable.  
If your folder is `gobasics`, you might just write `go mod init gobasics` so that the module path matches the folder name.  
But this is **not required**.


![image-882.png](../../Images/image-882.png)


### Why is it useful?

Without `go mod init`, Go doesnâ€™t know:

- What the project is called.
    
- How to resolve imports.
    
- What dependencies belong to this project.
    

`go mod init` sets the root of your project and creates the `go.mod` file, which Go uses to track dependencies.

---

ğŸ‘‰ Think of it like this:

- **`go mod init` = registering your projectâ€™s â€œpassport nameâ€**.
    
- That name can be simple (`gobasics`) if youâ€™re just learning,  
    or a full GitHub path (`github.com/username/project`) if you want others to import it.

![image-883.png](../../Images/image-883.png)


![image-884.png](../../Images/image-884.png)


![image-885.png](../../Images/image-885.png)


- **Local project only** â†’ `go mod init gobasics` (short and simple).
    
- **Project you plan to share/publish** â†’ `go mod init github.com/username/reponame`


**Go does not allow relative imports like `../`**.

![image-886.png](../../Images/image-886.png)


![image-887.png](../../Images/image-887.png)


### How import works here

1. You wrote `import "gobasics/utils"`.
    
2. Go checks your `go.mod` and sees `module gobasics`.
    
3. It knows `gobasics` points to the root of your current project.
    
4. Then it looks inside the `utils` folder in your project root and finds `math.go`.
    

âœ… This works even **without using relative paths** like `../utils`.


