## â˜ï¸ Evolution: Physical Machines â†’ VMs â†’ Containers

### ğŸ”§ 1. **Physical Machines (Pre-cloud era)**

- One app per machine.
    
- Wasted resources (CPU, RAM unused).
    
- Hard to scale or replicate.
    
- Expensive and slow to provision new servers.
    

---

### âš™ï¸ 2. **Virtual Machines (VMs)**

> Multiple virtual OSes running on one physical host via a **hypervisor**.

- âœ… Better resource usage.
    
- âœ… Isolation: VM1 crash wonâ€™t affect VM2 (usually).
    
- âŒ Each VM is heavy (includes OS).
    
- âŒ Boot time is slow.
    
- âŒ Resource duplication (multiple OSes running).
    
- âŒ Harder to scale up/down quickly.



## ğŸ—ï¸ Real Cloud Scenario: Public Cloud Providers

In AWS, Azure, GCP:

> One physical server = many virtual machines (VMs) from different customers.

So, your VM might **share hardware** with someone else's VM. This creates new risks:

### ğŸ˜¬ Potential Problems:

|Issue|Explanation|
|---|---|
|**Noisy Neighbor**|One VM uses too much CPU or I/O, affecting yours.|
|**Security breaches**|Exploits like Spectre can leak data across VMs.|
|**Hardware failure**|If the physical machine fails, all VMs on it go down.|
|**Inefficient scaling**|Spinning up new VMs is slow and heavy.|
## ğŸš€ Enter: Containers (like Docker)

Unlike VMs:

- âœ… **Share the same OS kernel**, so they are lightweight.
    
- âœ… **Start in milliseconds**.
    
- âœ… Can run **hundreds per machine** with less overhead.
    
- âœ… Easier to pack and migrate across systems.
    
- âœ… Perfect for **microservices**, **scaling**, and **cloud-native apps**.



### ğŸ“Š VM vs Container: In a Cloud Scenario

| Feature     | Virtual Machines        | Containers             |
| ----------- | ----------------------- | ---------------------- |
| Boot Time   | Minutes                 | Seconds / Milliseconds |
| Size        | GBs (whole OS)          | MBs (just app + deps)  |
| OS per unit | Each has its own        | Shared kernel          |
| Isolation   | Strong (hardware-level) | Medium (process-level) |
| Performance | Heavier                 | Faster                 |
| Portability | Lower                   | Very high              |
## â˜ï¸ Cloud + Containers = ğŸ”¥

Thatâ€™s why modern cloud systems donâ€™t just use VMs. They:

- Run containers **inside VMs**.
    
- Use **orchestrators like Kubernetes** to manage them.
    
- Achieve high-density, fast-scaling, secure deployments.
    

---

### So to sum up:

> Cloud gave us flexibility. But containers gave us **speed, portability, efficiency**, and **developer freedom** within that cloud.


## ğŸ”¹ What Is Docker?

Docker is a tool that helps you run your application in a clean, consistent environment, no matter what machine you're using.


### ğŸ’¡ Real-Life Problem:

You write an app on your laptop, it works.  
Your friend runs the same app on their laptop â€” it breaks.  
Why? Different setup (different Python/Node version, missing libraries, etc.)

### âœ… Docker Solves This:

Docker creates a small, isolated box (called a â€œcontainerâ€) with your app + everything it needs â€” and it runs exactly the same on every machine.

## ğŸ–¼ï¸ What Is a Docker Image?

Think of it like a ğŸ“¸ photo of your appâ€™s full setup.

- It includes:
    
    - Your app code
        
    - Installed packages (e.g., pip/npm)
        
    - System tools
        
    - Config files
        

âœ… Itâ€™s **read-only** (you can't change the image once it's made).  
You use it to create containers.


## ğŸ“¦ What Is a Docker Container?

A Docker container is like a **real, working toy made from the blueprint** (the image).

- Itâ€™s the running version of your app
    
- Itâ€™s isolated (doesnâ€™t affect your host or other containers)
    
- You can run many containers from the same image
    

ğŸ§  Tip:  
Image = Recipe / Blueprint  
Container = Cooked Meal / Live Toy



![image-299.png](../../Images/image-299.png)


## ğŸ†š Dockerfile vs Docker Image

|**Dockerfile** ğŸ“|**Docker Image** ğŸ“¦|
|---|---|
|A **text file** with **instructions** to build a Docker image.|The actual **output (product)** created by running the Dockerfile â€” it's like a **snapshot** or **blueprint** of your app's environment.|
|Think of it like a **recipe**.|Think of it like the **final cake** made from that recipe.|
|You **write it manually** (or generate it).|You **build** it using `docker build`.|
|Not executable by itself.|Used to **create containers** using `docker run`.|
![image-300.png](../../Images/image-300.png)


### ğŸ¯ Real-Life Analogy (extended)

âœ… **Dockerfile** = _Recipe Card_

> Instructions on how to make the cake.

âœ… **Docker Image** = _Frozen Cake_

> The cake is fully prepared and stored in the freezer, ready to be used any time.

âœ… **Container** = _Serving the Cake on a Plate_

> This is **taking the frozen cake out**, **unwrapping it**, and **putting it on the table for someone to eat**.  
> Itâ€™s the **running, active instance** of the image.

---

ğŸ”¹ In more precise terms:

- The **image** is inert â€” itâ€™s _just_ the packed environment with everything set up.
    
- A **container** is what happens when Docker **starts that image**, adds a writable layer on top (so it can change state), gives it resources (CPU, RAM), and connects it to the outside world (network ports).
    

---

ğŸ’¡ **Visual Metaphor Recap**

| Concept          | Analogy                       |
| ---------------- | ----------------------------- |
| **Dockerfile**   | ğŸ“„ Recipe Card                |
| **Docker Image** | ğŸ‚ Frozen Cake in the Freezer |
| **Container**    | ğŸ½ï¸ Cake Served, Ready to Eat |
## ğŸ‘¥ What Happens When Multiple Containers Run?

âœ… Each container:

- Has its own file system
    
- Has its own processes
    
- Is isolated from others
    

âš ï¸ They all share the hostâ€™s Linux Kernel (not the full OS)

You can:

- Run 10 containers of the same image
    
- Give each container its own port
    
- Limit CPU/RAM for each


![image-301.png](../../Images/image-301.png)

![image-302.png](../../Images/image-302.png)


![image-303.png](../../Images/image-303.png)

![image-304.png](../../Images/image-304.png)

![image-305.png](../../Images/image-305.png)

![image-306.png](../../Images/image-306.png)


## ğŸ†š Docker Image vs Docker Container

|Aspect|**Docker Image** ğŸ“¦ (Frozen Cake)|**Docker Container** ğŸ½ï¸ (Cake on Plate)|
|---|---|---|
|**Definition**|Read-only, packaged snapshot of your app|A running, isolated instance created from an image|
|**State**|Static / not running|Dynamic / actively running|
|**Created by**|`docker build` (from a Dockerfile)|`docker run` (from an image)|
|**Persistence**|Does not change once built|Can have temporary writable changes|
|**Use case**|Acts as a template or mold|Used to run and test actual applications|
|**Filesystem**|Read-only|Has a writable layer added on top|
|**Multiple instances**|One image can spawn many containers|Each container is an independent runtime|
|**Analogy**|A frozen cake in the freezer|That cake served and being eaten|

![image-307.png](../../Images/image-307.png)


## â“ WHY install the official Node.js image?

Because:

- âœ… You want a **clean, portable, isolated environment** with Node.js already installed.
    
- âœ… You donâ€™t want to worry about OS differences or manually installing Node.js on every server or dev machine.
    
- âœ… Youâ€™re building a Node.js app and want to **package and run it inside a container**.
    

ğŸ“¦ Official Docker images are **trusted base environments** provided by Node.js team (on Docker Hub), pre-configured and tested.


## ğŸš€ BASIC DOCKER COMMANDS

### ğŸ”§ Image Commands

|Command|Description|
|---|---|
|`docker build -t <name> .`|Build an image from Dockerfile in current directory|
|`docker images`|List all Docker images on your system|
|`docker rmi <image_id>`|Remove an image|

---

### ğŸš€ Container Commands

|Command|Description|
|---|---|
|`docker run <image>`|Run a container from an image|
|`docker run -it <image>`|Run interactively (like a terminal)|
|`docker run -d <image>`|Run in detached mode (in background)|
|`docker run -p 8080:3000 <image>`|Map host port 8080 to container port 3000|
|`docker run --name <container_name> <image>`|Give your container a name|

---

### ğŸ” Container Info

|Command|Description|
|---|---|
|`docker ps`|Show **running** containers|
|`docker ps -a`|Show **all** containers (even stopped)|
|`docker logs <container_id>`|View container logs|
|`docker inspect <container_id>`|Get low-level details about container|

---

### ğŸ›‘ Manage Containers

|Command|Description|
|---|---|
|`docker stop <container_id>`|Stop a running container|
|`docker start <container_id>`|Start a stopped container|
|`docker restart <container_id>`|Restart container|
|`docker rm <container_id>`|Remove a container|
|`docker exec -it <container_id> bash`|Open bash shell **inside** a running container|
![image-308.png](../../Images/image-308.png)
To run the docker image of node which we can pull easily!!

### ğŸ”¹ `docker run`

This tells Docker to start a new container from a given image.

---

### ğŸ”¹ `-it`

These are two options combined:

- `-i`: Keep STDIN open (interactive mode)
    
- `-t`: Allocate a pseudo-terminal (like a command prompt)
    

ğŸ‘‰ Useful for **running commands** and seeing **output live**.

---

### ğŸ”¹ `--rm`

This deletes the container **automatically after it exits**.

ğŸ“Œ Use when you **donâ€™t want leftover containers**.



## ğŸ§  `-it` = `-i` + `-t`

These are **two separate flags** that are commonly used together when you want to **interact with the container via the terminal**.


![image-309.png](../../Images/image-309.png)


![image-310.png](../../Images/image-310.png)

![image-311.png](../../Images/image-311.png)


TheÂ `docker`Â command is the primary command-line interface (CLI) tool used to interact with Docker, a platform for developing, shipping, and running containers.

## Main Structure

The typical format for a Docker command is:

`docker [COMMAND] [OPTIONS] [ARGUMENTS]`


- **COMMAND:**Â The task you want Docker to perform (likeÂ `run`,Â `ps`,Â `images`).
    
- **OPTIONS:**Â Flags that modify the commandâ€™s behavior (likeÂ `-it`,Â `--rm`).
    
- **ARGUMENTS:**Â Additional information needed for the command (such as image names or container IDs)

## Common Docker Commands Explained

- `docker run IMAGE`: Creates and starts a new container from the specified image (e.g.,Â `docker run alpine:3.18.2`).
    
    - `-it`: Runs the container in interactive mode with a terminal session.
        
    - `--rm`: Automatically removes the container after it exits.
        
- `docker ps`: Lists running containers.
    
- `docker ps -a`: Lists all containers, including stopped ones.
    
- `docker images`: Shows available images on your local machine.
    
- `docker ls`: While not a standalone command, often appears with options (for example, listing volumes or containers).
    
- `docker exec`: Runs a command inside an already running container.
    
- `docker stop CONTAINER`: Stops a running container.
    
- `docker rm CONTAINER`: Removes a stopped container.
    
- `docker rmi IMAGE`: Removes a Docker image.


## Â 1.`docker run --detach -it alpine:3.18.2`

- **Creates and starts a new Docker container**Â from theÂ `alpine:3.18.2`Â image.
    
- `--detach`: Runs the container in the background (detached mode).
    
- `-it`: Allocates an interactive terminal, allowing for user input and output if you attach later.
    

## 2.Â `docker ps`

- **Lists all running containers**, showing details like container ID, image used, uptime, and names.
    

## 3.Â `docker attach <CONTAINER_ID>`

- **Re-attaches your terminal to a running container**, so you can interact with its shell.
    

## 4. Linux commands inside container (`ls`,Â `exit`)

- `ls`: Lists files and directories in the current directory (inside the container).
    
- `exit`: Exits the shell session in the container.
    

## 5.Â `docker rm <CONTAINER_NAME>`

- **Removes a stopped container**. The container must be stopped before removal.

```docker
docker run -it --detach --name custom-node node
```

## Breakdown:

- **docker run**: Starts a new Docker container.
    
- **-it**: Allocates an interactive terminal session. This allows you to interact with the container, though itâ€™s more common in attached mode.
    
- **--detach**: Runs the container in the background (â€œdetached modeâ€).
    
- **--name custom-node**: Assigns the nameÂ `custom-node`Â to your container for easier reference.
    
- **node**: The image to useâ€”here, it uses the official â€œnodeâ€ image from Docker Hub.

![image-312.png](../../Images/image-312.png)

![image-313.png](../../Images/image-313.png)


![image-314.png](../../Images/image-314.png)

The key difference betweenÂ `docker run -it node`Â andÂ `docker run -it node bash`Â lies inÂ _what command is executed_Â when the container starts:

## 1.Â `docker run -it node`

- **What happens:**Â This starts a new container from the officialÂ `node`Â image and runs itsÂ _default command_.
    
- **Default command (ENTRYPOINT):**Â For the Node image, the default is to launch the Node.js REPL (interactive Node console). You see a prompt likeÂ `>`, where you can type JavaScript code directly.
    
- **Terminal:**Â Youâ€™re interacting withÂ _Node.js_, not a Linux shell.
    

## 2.Â `docker run -it node bash`

- **What happens:**Â This starts the sameÂ `node`Â image, butÂ _overrides the default command_Â and instead runsÂ `bash`Â (the Bash shell).
    
- **Terminal:**Â Now, you get a real Linux shell prompt (`root@...:/#`), where you can run Linux commands (`ls`,Â `pwd`,Â `cat`, etc.).
    
- **Bash as shell:**Â Youâ€™re in aÂ _full Linux environment_, able to run any shell commands or scripts inside the container.



![image-315.png](../../Images/image-315.png)


In Docker commands,Â **tags**Â are optional labels attached to Docker images to specify a particular version or variant of that image. A Docker image name typically looks like this:

`<repository>:<tag>`

- TheÂ **repository**Â is the name of the image (for example,Â `node`Â orÂ `ubuntu`).
    
- TheÂ **tag**Â identifies a specific version or variant of that image (for example,Â `18.04`,Â `3.18.2`, orÂ `latest`).
    

If no tag is provided, Docker defaults to the tagÂ `latest`.

## Why are tags important?

- They help distinguish between different versions of the same image. For example,Â `ubuntu:20.04`Â andÂ `ubuntu:18.04`Â are different versions of the Ubuntu image.
    
- Tags allow precise control over which image version you use when running or pulling an image.
    
- They can represent different builds, environments (likeÂ `dev`,Â `prod`), or configurations (likeÂ `alpine`Â vs.Â `buster`Â variants).



## Examples:

- `docker run node`Â is equivalent toÂ `docker run node:latest`Â â€” it runs the latest Node.js image.
    
- `docker run alpine:3.18.2`Â runs the Alpine Linux image specifically tagged version 3.18.2.
    
- `myapp:v1`Â andÂ `myapp:v2`Â would be two different tagged versions of your custom image calledÂ `myapp`.


Tags in Docker commands identify specific versions or variants of images, allowing you to manage and run the exact image you want. They are written after the image name following a colon (`:`). Without a tag, Docker assumes theÂ `latest`Â tag by default.

This tagging system is crucial for version control, deployment consistency, and collaboration when using Docker images.

![image-316.png](../../Images/image-316.png)


## `docker run -it python bash`

- This command starts the same Python image,Â **but overrides the default command**Â and launches theÂ `bash`Â shell instead.
    
- Now you get aÂ **Linux shell prompt**Â (`root@...:/#`), not a Python prompt.
    
- From here, you can run Linux commands. Now if do python3 now it will be the same  as of the above!!

## LINUX COMES WITH THE IMAGES 
- **Docker images are layered:**Â TheÂ `node`Â image is builtÂ _on top of_Â a base Linux image, typicallyÂ **Debian**,Â **Ubuntu**, orÂ **Alpine**.
    
    - The base layer is a minimal operating system (Linux).
        
    - On top of that, packages like Node.js, npm, and other tools are added.
        
- **You never separately install Linux:**Â When you specifyÂ `docker run node`, Docker automatically pulls the full image, whichÂ _includes both_Â Node.js and a minimal Linux OS.
    
- **Thatâ€™s why:**Â When you checkÂ `docker inspect node`, you see environment variables likeÂ `PATH`,Â `PYTHON_VERSION`, etc., plus OS details (`"Os": "linux"`). Itâ€™s because youâ€™re actually running a full Linux systemâ€”just a stripped-down one custom-built for containers.


## 1. What isÂ `docker inspect`?

TheÂ `docker inspect`Â command displaysÂ **detailed, low-level information**Â about DockerÂ objects. TheseÂ can be:

- Containers
    
- Images
    
- Networks
    
- Volumes
    
- Plugins
    
- Nodes
    

It returnsÂ this informationÂ inÂ **JSON formatÂ by default**, givingÂ you a completeÂ snapshot of howÂ an object isÂ configured andÂ its current state



## 3. What Information Can You Get fromÂ `docker inspect`?

The output includes:

- **Config details**: Environment variables, commands, labels, entrypoint, etc.
    
- **Image details**: Parent image, creation time, architecture, tags.
    
- **Container details**: Mounts, network settings (IP/MAC address), volumes, ports, restart policies, state (running, exited, paused), log path.
    
- **Network**: Driver, subnet, connected containers, IPAM config.
    
- **Volumes**: Mount point, usage.
    

This is essential for troubleshooting (Why isnâ€™t my app reachable? What volumes or networks are attached?), automation, debugging, or understanding how something was set u


## 1.Â `docker run -dit python`

- **Purpose:**Â Starts a new container from theÂ `python`Â image in detached mode and with interactive terminal allocation.
    
    - `-d`: Runs the container in the background (detached mode).
        
    - `-i`: Allocates an interactive STDIN stream (allowing you to keep input open).
        
    - `-t`: Allocates a pseudo-TTY (gives you a terminal interface).
        
- **Result:**Â A new container is started, running the default command (`python3`Â interpreter), and youâ€™ll get the container ID in the output.
    
- **Use case:**Â Launch background services or shells without immediately attaching to them[](https://docs.docker.com/reference/cli/docker/container/run/)[](https://www.geeksforgeeks.org/devops/docker-run-command/)[](https://refine.dev/blog/docker-run-command/)[](https://phoenixnap.com/kb/docker-run-command-with-examples)[](https://tutorials.ducatindia.com/docker/docker-run-command).

## 2.Â `docker ps`

- **Purpose:**Â Lists all running containers on your system.
    
- **Output columns:**
    
    - `CONTAINER ID`
        
    - `IMAGE`
        
    - `COMMAND`Â (entrypoint running in container)
        
    - `CREATED`Â (how long ago container started)
        
    - `STATUS`Â (running, paused, exited, etc.)
        
    - `PORTS`Â (any ports mapped to host)
        
    - `NAMES`Â (auto-generated or user-provided container name)
        
- **Common options:**
    
    - `docker ps -a`: Shows all containers, including stopped ones.
        
- **Use case:**Â Monitor or manage current containers, check health/status, find container IDs for later command


## 3.Â `docker pause <container_id>`

- **Purpose:**Â Suspends (freezes) all processes inside the specified container(s), using the Linux cgroups freezer.
    
- **How it works:**
    
    - All running processes are put â€œon holdâ€ by Docker.
        
    - The containerâ€™s state, memory, open files/connections are preserved.
        
    - The containerâ€™sÂ `STATUS`Â becomes â€œPaused.â€
        
- **Why use it?**
    
    - Temporarily halt processing for maintenance, resource saving, or testsâ€”without losing state.
        
    - Does not stop or kill the container

## Â `docker unpause <container_id>`

- **Purpose:**Â Resumes (unfreezes) all processes in a container that was previously paused.
    
- **Effect:**Â The container continues running exactly where it left off, with all resources and connections intact.
    
- **Use case:**Â Quickly bring containers back online after maintenance or intentional pause




## 5.Â `docker kill <container_name|container_id>`

- **Purpose:**Â ImmediatelyÂ _forcibly_Â terminates one or more running containers.
    
    - By default, sends theÂ **SIGKILL**Â signal (cannot be caught or ignored).
        
    - Optionally, you can specify a different signal withÂ `--signal`.
        
- **Effect:**Â The containerâ€™s process (and thus the container) stops instantly, without giving apps a chance to shut down gracefully.
    
    - All resources and open files are closed abruptly.
        
- **When to use:**Â If a container is unresponsive, needs instant shutdown, or wonâ€™t stop withÂ `docker stop`.
    
- **Caution:**Â Data loss (unwritten buffers) or corruption can occur for stateful applications


## RunningÂ `docker run -it ubuntu`

- This runs the Ubuntu image interactively and executes theÂ **default command**Â configured for the image.
    
- For official Ubuntu images, the default command is typicallyÂ `/bin/bash`Â anyway.
    
- So you get an interactive Bash shell prompt immediately.
    

## RunningÂ `docker run -it ubuntu bash`

- This explicitly overrides the default command and runsÂ `/bin/bash`.
    
- You get the same interactive Bash shell prompt.


## `docker run`

- **Purpose:**Â Creates and starts aÂ **new container**Â from the specified image.
    
- **How to Use:**
    
    text
    
    `docker run [OPTIONS] IMAGE [COMMAND]`
    
- **What You Mention:**
    
    - You specify theÂ **image name**Â (e.g.,Â `ubuntu`,Â `node`,Â `python`), not a container.
        
- **What It Does:**
    
    - Pulls the image (if missing), creates a new container, and starts it with theÂ **optional command**Â or the imageâ€™s default.
        
- **Example:**
    
    text
    
    `docker run -it ubuntu`
    
    (Creates and runs a new container from theÂ `ubuntu`Â image.)
    

## `docker exec`

- **Purpose:**Â Runs aÂ **new command**Â in anÂ **already running container**.
    
- **How to Use:**
    
    text
    
    `docker exec [OPTIONS] CONTAINER [COMMAND]`
    
- **What You Mention:**
    
    - You specify anÂ **existing containerâ€™s name or ID**.
        
- **What It Does:**
    
    - Executes the given command inside the existing container (without creating or starting a new one).
        
- **Example:**
    
    text
    
    `docker exec -it my_ubuntu_container ls`
    
    (RunsÂ `ls`Â inside theÂ `my_ubuntu_container`.)
    

## Key Differences Table

|Command|You Specify|What It Does|When to Use|
|---|---|---|---|
|`docker run`|**Image name**|Creates and starts aÂ _new container_|Start a new environment|
|`docker exec`|**Container name/ID**|Runs command inÂ _existing container_|Access a running container|

**Summary:**

- UseÂ `docker run`Â withÂ **image names**Â to start new containers.
    
- UseÂ `docker exec`Â withÂ **container names or IDs**Â to interact with containers that areÂ **already running**.


## 1.Â `docker build .`Â andÂ `docker build -t my-basic-image .`

- **Purpose:**Â Builds a Docker image from a Dockerfile located in the current directory (`.`).
    
- **Process:**
    
    - Docker reads instructions from a file namedÂ `Dockerfile`.
        
    - It creates an image layer by layer according to the commands in the Dockerfile. Each step outputs its status.
        
- **Usage:**
    
    - `docker build .`Â simply builds the image.
        
    - `docker build -t my-basic-image .`Â does the same build, but also tags (names) the image asÂ `my-basic-image`, making it easier to reference later.
        

## Key flags:

- `-t`Â orÂ `--tag`: Assigns a name (and optionally a tag) in theÂ `name:tag`Â format. Example:Â `my-basic-image:latest`.



## 2.Â `docker run -it IMAGE_ID`

- **Purpose:**Â Runs a container from a specified image.
    
- **Options:**
    
    - `-i`Â (`--interactive`): Keeps STDIN open, so you can interact with the container.
        
    - `-t`Â (`--tty`): Allocates a pseudo-terminal, making interactive work in a shell possible.
        
- **Usage:**
    
    - `docker run -it 848435386cfa`: Runs the container in interactive mode.
        
    - Output (`100`): This container appears to execute a script or command that printsÂ `100`Â (as defined by the Dockerfile).
        
    - `docker run -it 848435386cfa bash`: Runs a new shell (`bash`) inside the container, giving you a shell prompt to explore the container interactively.



## 3. Exploring the Container (`cat /etc/issue`)

- **Purpose:**Â Reads and displays system information.
    
- **Command:**
    
    - `cat /etc/issue`: Shows the Linux distribution information inside the container. Useful to know what OS or base image the container uses.
        

## 4. Exiting the Container (`exit`)

- **Purpose:**Â Terminates the interactive shell session, thereby stopping the container if no other process is running.
    
- **Typical result:**Â You return to the host machineâ€™s shell



## 5.Â `docker rmi IMAGE_ID`

- **Purpose:**Â Removes a Docker image from the local storage.
    
- **Common issue:**Â You may get an error if the image is being used by a running or stopped container.
    
    - Example error: â€œunable to delete â€¦ image is being used by stopped container â€¦â€
        
- **Reason:**Â Docker prevents image deletion if it's still associated with a container (running or exited).
    

## 6. Forcibly Removing an Image (`docker rmi IMAGE_ID -f`)

- **Purpose:**Â Forces removal of the image even if containers (stopped or running) depend on it.
    
- **Usage:**
    
    - `docker rmi 848435386cfa -f`
        
- **Effect:**Â The image is deleted, and any containers using it are left in a dangling state or are also removed depending on Dockerâ€™s handling.


## 7.Â `docker run -it my-basic-image:latest`

- **Purpose:**Â Runs a container from a tagged image (`my-basic-image:latest`) in interactive mode, as explained above.
    
- **Typical outcome:**Â If the image entrypoint/script prints output (likeÂ `100`), youâ€™ll see it in your terminal.



## Summary Table

|Command|Description|Common Usage Scenario|
|---|---|---|
|`docker build .`|Builds Docker image from current directoryâ€™s Dockerfile|Create a new image from a Dockerfile; default (unnamed) image tag|
|`docker build -t NAME .`|Builds andÂ _tags_Â the image for easy referencing|Build and name versioned/project-specific images|
|`docker run -it IMAGE`|Runs a container from an image in interactive mode with TTY|Test image, run shell, experiment interactively|
|`docker run -it IMAGE bash`|Starts a bash shell inside the running container|Open a terminal inside the container for inspection/debugging|
|`cat /etc/issue`|Displays Linux distribution inside a container|Learn base image OS in container|
|`exit`|Exits interactive container shell|Stop interactive session|
|`docker rmi IMAGE`|Removes Docker image from your local system|Clean up unused images|
|`docker rmi IMAGE -f`|Forcefully removes image, even if in use by stopped/running containers|Remove images blocked by dependencies|
|`docker run -it my-basic-image`|Runs a container from a customly named image, interactively|Start container from your own image|

## Additional Tips

- To see all images:Â `docker images`Â orÂ `docker image ls`.
    
- To see all containers (including stopped):Â `docker ps -a`.
    
- To remove stopped containers:Â `docker rm CONTAINER_ID`.
    
- To prune unused images and containers:Â `docker system prune`


Dockerfile should haveÂ **no extension**Â when you create it in VS Code or any code editor. By industry convention, the file is simply namedÂ `Dockerfile`Â (noÂ `.txt`,Â `.docker`, or any other extension). This naming is important because Docker's build tools look specifically for a file calledÂ `Dockerfile`Â in your project directory when building images, unless you specify a different file name with theÂ `-f`Â flag.

## Why Might We DeleteÂ `node_modules`Â Before Building the Docker Image?

- **Platform Compatibility:**Â TheÂ `node_modules`Â folder may contain binaries or native modules compiled specifically for your host OS (e.g., Windows, Mac), but the Docker image likely uses a Linux environment. Copying host modules could cause errors.
    
- **Clean Install:**Â Itâ€™s better practice to let Docker install dependencies inside the image usingÂ `npm ci`Â orÂ `npm install`, ensuring only the necessary, production-specific modules are included.
    
- **Image Size/Layering:**Â ExcludingÂ `node_modules`Â by using aÂ `.dockerignore`Â file keeps images lean, reduces layer sizes, and avoids caching issues.


**Workflow:**

- AddÂ `node_modules`Â toÂ `.dockerignore`Â (not shown in your images, but strongly recommended).
    
- When youÂ `COPY . .`, everything except ignored files/folders goes into the image.
    
- Then runÂ `npm ci`Â to install fresh, compatible modules inside the image.
    




## What Does theÂ `CMD`Â Instruction Do in Dockerfile? How, Why, and When Does It Work?

## What does it do?

- TheÂ `CMD`Â command specifies the default command to run when a container starts from the image.
    
- Example from your Dockerfile:
    
    text
    
    `CMD ["node", "index.js"]`
    
    This tells Docker: â€œwhen you start a container from this image, runÂ `node index.js`.â€
    

## How does it work?

- During build time,Â `CMD`Â just records the intended instruction.
    
- At container runtime, unless you specify a different command, Docker executes the CMD (in this case, starts your Node.js server).

## Why does it work?

- Docker containers need a process to run when started; usually, this is your applicationâ€™s entrypoint (like a Node.js server for web backends).Â `CMD`Â provides that default process.
    
- If you run the container with a different command, Docker overrides theÂ `CMD`.
    

## When does it work?

- `CMD`Â runs whenever the container is startedÂ _without_Â a different command.
    
- If you run withÂ `docker run my-image some-other-command`, it replacesÂ `CMD`.
    
- If you just runÂ `docker run my-image`, Docker uses the CMD.
    

## What does it do practically?

- In your case, it boots the server defined inÂ `index.js`.


## How Can My Machine Contact the Server Inside the Container? (Networking & Ports)

By default, your Node.js app inside the container listens on portÂ `3000`.  
**However, this port is inside the containerâ€”not accessible from your own machine unless mapped.**

- **Exposing the port:**Â Use theÂ `-p`Â orÂ `--publish`Â option to map container port to host port:
    
    text
    
    `docker run -it --init --publish 3000:5000 my-express-server:latest`
    
    This maps your hostâ€™s portÂ **3000**Â to theÂ **containerâ€™s 5000**Â (typo in image, should likely beÂ `3000:3000`Â if the app uses 3000 inside and outsideâ€”but mapping is flexible).
    
    - Now, visitingÂ `localhost:3000`Â onÂ **your machine**Â will forward requests inside the container (to your Node.js server).



