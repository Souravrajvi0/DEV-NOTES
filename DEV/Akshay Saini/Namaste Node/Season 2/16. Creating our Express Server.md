---
view-count: 6
---
Here’s a list of common npm commands along with their brief descriptions:

1. **`npm init`**: Initializes a new Node.js project and creates a `package.json` file.
    
2. **`npm install`**: Installs the dependencies listed in `package.json`. If you provide a package name, it installs that package.

`npm install`

- **What Happens**:
    - npm reads the `package.json` file.
    - It installs all the packages listed under `"dependencies"` and `"devDependencies"`.
    - A `node_modules` folder is created (if it doesn’t already exist) where all installed packages are stored.
    - A `package-lock.json` file is also created (or updated) to lock the exact versions of the installed packages.

`npm install express`

- **What Happens**:
    - npm installs the latest version of the `express` package.
    - The package is added to the `node_modules` folder.
    - The `package.json` file is updated to include `express` in the `"dependencies"` section.

3. **`npm uninstall`**: Removes a package from the `node_modules` directory and updates `package.json`.
    If you want to remove all installed packages and reset your project, you can manually delete the `node_modules` directory and the `package-lock.json` file. However, there's no built-in command to uninstall all packages at once.
4. **`npm update`**: Updates the packages to their latest versions based on the version range specified in `package.json`.
    
5. **`npm list`**: Displays a tree of installed packages.
    
6. **`npm run <script>`**: Runs a script defined in the `scripts` section of `package.json`.
    
7. **`npm publish`**: Publishes a package to the npm registry.
    
8. **`npm login`**: Authenticates a user to the npm registry.
    
9. **`npm logout`**: Logs out a user from the npm registry.
    
10. **`npm cache clean --force`**: Clears the npm cache.
    
11. **`npm audit`**: Checks for vulnerabilities in installed packages.
    
12. **`npm outdated`**: Checks for outdated packages.
    
13. **`npm prune`**: Removes extraneous packages that are not listed in `package.json`.
    
14. **`npm ci`**: Installs dependencies from `package-lock.json` for a clean slate.
    
15. **`npm config`**: Manages npm configuration settings

![16. Creating our Express Server-20241016180006176.webp](../../../Images/16.%20Creating%20our%20Express%20Server-20241016180006176.webp)
->This app.js is the entry point of the application we're going to make for oursleves
-> Now we'll have to create a server!

![16. Creating our Express Server-20241016180304355.webp](../../../Images/16.%20Creating%20our%20Express%20Server-20241016180304355.webp)
![16. Creating our Express Server-20241016180454483.webp](../../../Images/16.%20Creating%20our%20Express%20Server-20241016180454483.webp)
-> To check the version of the package installed in your project using the command line interface (CLI), you can use one of the following methods:

1. **Using npm list**:
    `
    npm list express`
    
2. **Using npm view**:
   
	`npm view express version`
    
3. **Checking package.json**: You can also open your `package.json` file and look for the "express" entry under "dependencies" or "devDependencies". It will show the version number there.

-> The `package.json` and `package-lock.json` files serve different purposes in a Node.js project:
### `package.json`
 IT IS CREATED WHEN WE DO NPM INIT THE FIRST TIME 
- **Purpose**: This file is used to manage project metadata, dependencies, scripts, and configurations.
- **Contents**:
    - Project name and version.
    - List of dependencies and their version ranges.
    - Scripts for running tasks (e.g., start, test).
    - Other metadata like author, license, and description.
- **Editable**: You can manually edit this file to add or remove dependencies and update scripts.

### `package-lock.json`
IT IS CREATED WHEN WE DO NPM INSTALL THE FIRST TIME , ANY OF THE PACKANGES 
- **Purpose**: This file is automatically generated when you install dependencies. It locks the versions of all installed packages, ensuring consistency across different environments.
- **Contents**:
    - Exact version numbers of all dependencies and their dependencies (transitive dependencies).
    - A complete tree of dependencies, including nested dependencies.
- **Not Editable**: You should not manually edit this file. It is updated automatically when you run commands like `npm install`.
### Why We Need `package-lock.json`

1. **Version Locking**:
    
    - `package.json` specifies the version ranges of dependencies (e.g., `^1.0.0`, `~1.0.0`). This means that when you install packages, you might get different versions each time based on those ranges.
    - `package-lock.json`, on the other hand, locks the exact versions of all installed packages, ensuring that everyone working on the project (or any deployment) uses the same versions. This prevents "it works on my machine" issues.
2. **Dependency Tree**:
    
    - `package-lock.json` captures the entire dependency tree, including nested dependencies. This means it records not just the top-level dependencies but also their dependencies, ensuring that the same versions of all packages are used.
3. **Faster Installations**:
    
    - When you run `npm install`, npm can use `package-lock.json` to install dependencies more quickly, as it doesn't need to resolve version ranges again. It can directly install the exact versions specified.
4. **Consistency Across Environments**:
    
    - By committing `package-lock.json` to version control, you ensure that any developer or CI/CD pipeline that installs the project will get the exact same dependencies, leading to more predictable builds.
5. **Security**:
    
    - `package-lock.json` can help in identifying and fixing security vulnerabilities by providing a detailed view of all dependencies, which can be analyzed by tools like npm audit


The `node_modules` folder is a key component of a Node.js project. Here’s more about it:
### **When Both `package.json` and `package-lock.json` Are Present**

- **Running `npm install`**:
    - **Step 1**: npm first checks for the existence of the `package-lock.json` file. If it exists, npm prioritizes it over `package.json` for installing dependencies.
    - **Step 2**: npm will read the exact package versions listed in `package-lock.json` and install those versions into the `node_modules` directory.
    - **Step 3**: If `package-lock.json` is up to date with respect to `package.json`, npm will simply install the exact versions listed without needing to resolve the versions again.

### 2. **When `package-lock.json` Is Not Present**

- **Running `npm install`**:
    - If `package-lock.json` is not found, npm falls back to `package.json` to determine which packages to install.
    - npm will read the dependencies listed in `package.json`, resolve the appropriate versions based on the specified version ranges, install those packages, and then create a new `package-lock.json` file reflecting the exact versions installed.
### Overview of `node_modules`

1. **Purpose**:
    
    - The `node_modules` folder is where all the project’s dependencies are installed. When you run commands like `npm install`, Node Package Manager (npm) downloads the packages listed in your `package.json` and places them in this directory.
2. **Structure**:
    
    - The folder contains all the installed packages and their dependencies. Each package can have its own `node_modules` folder if it has dependencies of its own, leading to a nested structure.
    - Each package typically includes its own `package.json` file, which describes the package, its version, and its dependencies.
3. **Size**:
    
    - The `node_modules` folder can become quite large, especially for projects with many dependencies. This is because it includes not only the direct dependencies but also all their transitive dependencies.
4. **Exclusion from Version Control**:
    
    - It’s common practice to exclude the `node_modules` folder from version control systems like Git. This is done by adding it to the `.gitignore` file since it can be regenerated from the `package.json` and `package-lock.json` files. This keeps the repository lightweight.
5. **Global vs. Local Installations**:
    
    - Packages can be installed locally (in the `node_modules` folder of your project) or globally (accessible from anywhere on your system). Global packages are typically installed with the `-g` flag, and they reside in a separate global directory.


When you install Express (or any npm package), you might notice that the `node_modules` folder contains many files and subfolders. This is due to several reasons:
-> EVERY NODE MODULE WILL ALSO CONTAIN package.json and package-lock.json
### Reasons for Many Files in `node_modules`

1. **Dependencies of Express**:
    
    - Express itself has its own dependencies. When you install Express, npm installs not just the Express package but also all the packages that Express depends on. Each of these dependencies can also have their own dependencies, leading to a nested structure.
2. **Transitive Dependencies**:
    
    - These are the dependencies of your dependencies. For example, if Express depends on Package A, and Package A depends on Package B, both Package A and Package B will be present in your `node_modules` folder.
3. **Versioning**:
    
    - npm manages multiple versions of the same package if different packages require different versions. This can lead to a larger number of packages being installed.
4. **Development Dependencies**:
    
    - Some packages may include development dependencies that are necessary for building or testing the package but are not required for running it. These are also included in the `node_modules` folder.
5. **Optional Dependencies**:
    
    - Some packages may have optional dependencies that are installed based on certain conditions. These can also contribute to the size of the `node_modules` folder



**When you run `npm install` for the first time in a project that has a `package.json` file, npm generates a `package-lock.json` file automatically. This file captures the exact versions of all the packages installed, as well as their dependencies.**


In a `package.json` file, which is used in Node.js projects to manage dependencies, `^` and `~` are version range specifiers. They define which versions of a dependency (library or package) your project is compatible with when you install or update packages.
![16. Creating our Express Server-20241016185122189.webp](../../../Images/16.%20Creating%20our%20Express%20Server-20241016185122189.webp)
Here's what they mean in simple terms:
### 1. **Caret (`^`)**:
 FOR AUTOMATIC UPDATION=AUTO UPDATE
- The `^` allows updates that **do not change the first non-zero number**. In other words, it will allow updates to **minor** and **patch** versions but will prevent updates to a new **major** version (which might introduce breaking changes).

**Example**:

- If your `package.json` has `"express": "^4.2.1"`, it means:
    - It will accept updates to versions like `4.9.0`, `4.2.5`, or `4.5.1`.
    - It will **not** accept updates to `5.0.0` or higher because it's a new major version, which might introduce breaking changes.

In short, `^4.2.1` means: "Allow versions `>= 4.2.1` but `< 5.0.0`."

### 2. **Tilde (`~`)**:

- The `~` allows updates to **patch** versions (the last number) but restricts updates to the **minor** or **major** versions. This is a more restrictive range than `^`.

**Example**:

- If your `package.json` has `"express": "~4.2.1"`, it means:
    - It will accept updates to versions like `4.2.2` or `4.2.5`.
    - It will **not** accept `4.3.0` or higher (new minor or major versions).

In short, `~4.2.1` means: "Allow versions `>= 4.2.1` but `< 4.3.0`."
### 1. **MAJOR Version**:

- The **first number** in the version (`1.2.3` → `1` is the MAJOR version).
- It changes when there are **breaking changes**. Breaking changes are changes that are **not backward compatible**, meaning the new version might not work with old code unless you update it.

**Example**: If the version goes from `1.5.0` to `2.0.0`, this usually means the update could break existing code, and you’ll need to modify your code to work with the new version.

### 2. **MINOR Version**:

- The **second number** in the version (`1.2.3` → `2` is the MINOR version).
- It changes when **new features** are added, but the changes are **backward compatible**. This means new features are introduced, but they don’t break the existing code that uses the package.

**Example**: If the version goes from `1.2.3` to `1.3.0`, it means the new version has additional features, but your existing code should work just fine without any changes.

### 3. **PATCH Version**:

- The **third number** in the version (`1.2.3` → `3` is the PATCH version).
- It changes when there are **bug fixes** or minor improvements that do **not affect compatibility**. These updates don’t add new features, just fix issues to make the package work better.

**How To Create a Server!**

```jsx
const express = require("express");
//Result: After this line executes, the express variable holds the exported functionality of the Express module, which is a function 
//that you can invoke to create an Express application.

const app=express();

app.listen(3000,()={
console.log("HELLLO);
});

```

- **`express()`**: This part is calling the `express` function that was imported in the previous line.
    - **What does it do?**: When you call `express()`, it creates a new instance of an Express application. This instance is what you will use to define routes, middleware, and handle requests.
- **Purpose of `app`**: The `app` variable now holds the instance of the Express application, which you can use to configure your server.

FILE MEIN CHANGE KARNE K BAD  FILE KO FIRSE SAVE KARKE SERVER KO FIRSE START KARNA PADTA HAI DHYAN RAKHNA BHAIYA.
![16. Creating our Express Server-20241016190845817.webp](../../../Images/16.%20Creating%20our%20Express%20Server-20241016190845817.webp)

-> Now To run a file pehle we used to do node app.js right?? Now We need to do nodemon app.js
-> But the best part about nodemon is that it will automatcially refresh the server whenever i make changes in the code!
-> But save karna code fir hi vo server ko refresh karega// automatically restart the server 

In this snippet from a `package.json` file, the `"scripts"` section defines custom commands that you can run for your project. These scripts are shortcuts for common tasks, and they help you avoid typing long commands manually each time.
### 1. `"start": "node src/app.js"`

- **Command**: `node src/app.js`
- **Explanation**:
    - This script tells Node.js to run the `app.js` file located in the `src` folder.
    - When you run `npm start` in your terminal, it executes `node src/app.js`, which starts your Node.js application by running the code in `app.js`.
    - This is a special, built-in script in npm. If you have a `"start"` script defined in your `package.json`, you can just run `npm start` without the `run` keyword.
    - Kyonki otherwise npm run start likhna padta na
    - If no `"start"` script is defined, npm will attempt to run `node server.js` by default (if `server.js` exists).

### 2.`"dev": "nodemon src/app.js"`

- **Command**: `nodemon src/app.js`
- **Explanation**:
    - This script uses `nodemon`, which is a tool that automatically restarts your Node.js application when it detects any changes in the source code.
    - When you run `npm run dev`, it starts the app with `nodemon`, and the app will automatically restart every time you change a file in your project.
This is a more general form and can be used for any script, not just `"start"`. In this case, you're explicitly running the `"start"` script defined in `package.json`, but you need to use the `run` keyword for non-special scripts (like `"dev"`, `"test"`, etc.).
Yes, you can absolutely use a random name for a script in your `package.json` to run `nodemon src/app.js` or any other command. The name of the script can be anything you like—it’s completely customizable.

